from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    User,
    Message
)
from telegram.error import TelegramError
from telegram.ext import CallbackContext, Application, ContextTypes
import time
import os
from modules.bot_utils import (
    validate_text,
    convert_to_voice,
    clear_dir,
    user_restricted,
    log_cmd,
    get_user_voice_dir,
    answer_query,
    logger,
    MAX_CHARS_NUM,
    RESULTS_PATH
)
from modules.tortoise_api import tts_audio_from_text
from modules.bot_db import db_handle
from modules.bot_settings import get_user_settings, UserSettings
from modules.bot_utils import SOURCE_WEB_LINK, QUERY_PATTERN_RETRY
import asyncio
from concurrent.futures import Future
from threading import Thread
from asyncio.events import AbstractEventLoop


class TTSWorkThread(Thread):
    """
    Thread class with active event loop to process incoming synthesis requests sequentially
    on separate thread
    """
    def __init__(self):
        Thread.__init__(self, name="tts_worker", daemon=True)  # Doesn't matter if stops unexpectedly
        self.loop = asyncio.new_event_loop()

    def run(self):
        asyncio.set_event_loop(self.loop)
        self.loop.run_forever()


tts_work_thread = TTSWorkThread()


@user_restricted
async def start_cmd(update: Update, context: CallbackContext) -> None:
    """Send a message when the command /start is issued."""
    user = update.effective_user
    db_handle.init_user(user.id)
    await update.message.reply_html(f"Hi, {user.mention_html()}! Call /help to get info about bot usage")


@user_restricted
async def gen_audio_cmd(update: Update, context: CallbackContext) -> None:
    """Send voice audio file generated by inference"""
    reply_id = update.message.message_id
    if not context.args:
        await update.message.reply_text("Error: invalid arguments provided, provide text next to the command", reply_to_message_id=reply_id)
        return

    text = ' '.join(context.args)
    if not validate_text(text):
        await update.message.reply_text("Error: Invalid text detected",
                                        reply_to_message_id=reply_id)
        return

    context.application.create_task(start_gen_task(update, context, text), update=update)


@user_restricted
async def retry_button(update: Update, context: CallbackContext) -> None:
    """launches tts task on a already completed one from the message keyboard"""
    query = update.callback_query
    context.application.create_task(answer_query(query), update=update)

    # TODO get actual message text instead of caption
    context.application.create_task(start_gen_task(update, context, query.message.caption), update=update)


async def help_cmd(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    log_cmd(user, "help_cmd")
    help_msg = ("Bot usage: select from the menu or type commands to interact with the bot. List of commands:\n"
                "<u>/gen</u> - provide text with this command and eventually receive a voice reply with your query,"
                "it may takes some time, depending on text length (from couple of seconds for a short sentence to "
                "couple of minutes for essays)\n"
                "<u>/add_voice</u> - to start a guided process of adding user voice for cloning, by providing the name and audio samples "
                "via files or voice recording(though voice quality will likely be subpar with bad mic recording)\n"
                "<u>/settings</u> - change user specific settings for voice synthesis\n"
                f"Take a look at source code for additional info at <a href='{SOURCE_WEB_LINK}'>GitHub</a>")
    await update.message.reply_html(help_msg)


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    if update and update.effective_message and update.effective_user:
        await update.effective_message.reply_html(f"Sorry {update.effective_user.mention_html()}, there has been a Server Internal Error when processing your command, please try again", reply_to_message_id=update.effective_message.message_id)


""" ------------------------------TTS related callbacks------------------------------ """


async def start_gen_task(update: Update, context: CallbackContext, text: str) -> None:
    user = update.effective_user
    filename_result = os.path.abspath(os.path.join(RESULTS_PATH, '{}_{}.wav'.format(user.id, int(time.time()))))
    settings = get_user_settings(user.id)
    loop = asyncio.get_running_loop()
    future = asyncio.run_coroutine_threadsafe(run_gen_audio(update, context.application, filename_result, settings, text, get_user_voice_dir(user.id), loop), tts_work_thread.loop)
    future.add_done_callback(eval_gen_task)


async def run_gen_audio(update: Update, app: Application, filename_result: str, settings: UserSettings, text: str, user_voices_dir: str, app_loop: AbstractEventLoop) -> None:
    """Running in tts_worker thread"""
    try:
        tts_audio_from_text(filename_result, text, settings.voice, user_voices_dir, settings.emotion, settings.samples_num)
    except Exception as e:
        async def handle_post_eval_gen_report_error(update: Update, app: Application, exc: Exception) -> None:
            app.create_task(post_eval_gen_report_error(update, exc), update=update)

        asyncio.run_coroutine_threadsafe(handle_post_eval_gen_report_error(update, app, e), app_loop)

    return update, app, filename_result, text, settings.samples_num


def eval_gen_task(future: Future) -> None:
    try:
        update, app, filename_result, text, samples_num = future.result()
    except Exception as e:
        logger.error(msg="Exception while handling eval_gen_task:", exc_info=e)
    else:
        app.create_task(post_eval_gen_task(update.effective_user, filename_result, text, samples_num, update.effective_message), update=update)


async def post_eval_gen_report_error(update: Update, exc) -> None:
    """handles errors from tts_worker thread"""
    clear_dir(RESULTS_PATH)
    logger.error(msg="Exception while handling run_gen_audio:", exc_info=exc)
    if update and update.effective_message and update.effective_user:
        await update.effective_message.reply_html(f"Sorry {update.effective_user.mention_html()}, your audio generation failed, please try again", reply_to_message_id=update.effective_message.message_id)


async def post_eval_gen_task(user: User, filename_result: str, text: str, samples_num: int, message: Message) -> None:
    try:
        for sample_ind in range(samples_num):
            sample_file = filename_result.replace(".wav", f"_{sample_ind}.wav")
            voice_file = convert_to_voice(sample_file)
            with open(voice_file, 'rb') as audio:
                keyboard = [[InlineKeyboardButton("Regenerate", callback_data=QUERY_PATTERN_RETRY)]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                if len(text) > MAX_CHARS_NUM:  # elide to prevent hitting max caption size
                    text = f"{text[:MAX_CHARS_NUM]}..."
                await message.reply_voice(voice=audio, caption=text, reply_to_message_id=message.message_id, reply_markup=reply_markup)

            logger.info(f"Audio generation DONE: called by {user.full_name}, for sample â„–{sample_ind}, with query: {text}")
    except Exception as e:
        clear_dir(RESULTS_PATH)
        raise TelegramError("Audio generation Error") from e
    else:
        clear_dir(RESULTS_PATH)
