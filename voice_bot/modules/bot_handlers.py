from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    User,
    Message
)
from telegram.ext import CallbackContext
import time
import os
from typing import Callable
from modules.bot_utils import (
    validate_text,
    convert_to_voice,
    clear_dir,
    user_restricted,
    log_cmd,
    get_user_voice_dir,
    logger,
    MAX_CHARS_NUM,
    RESULTS_PATH
)
from modules.tortoise_api import tts_audio_from_text
from modules.bot_db import db_handle
from modules.bot_settings_menu import get_emotion_name, Emotions


QUERY_PATTERN_RETRY = "c_re"


@user_restricted
async def start_cmd(update: Update, context: CallbackContext) -> None:
    """Send a message when the command /start is issued."""
    user = update.effective_user
    db_handle.init_user(user.id)
    await update.message.reply_html(f"Hi, {user.mention_html()}!")


@user_restricted
async def gen_audio_cmd(update: Update, context: CallbackContext) -> None:
    """Send voice audio file generated by inference"""
    user = update.effective_user
    logger.info(f"Audio generation called by {user.full_name}, with id: {user.id}, with query: {update.message.text}")
    reply_id = update.message.message_id
    if not context.args:
        await update.message.reply_text("Error: invalid arguments provided", reply_to_message_id=reply_id)
        return

    try:
        text = ' '.join(context.args)
        if not validate_text(text):
            await update.message.reply_text("Error: Invalid text detected",
                                            reply_to_message_id=reply_id)
            return

        await gen_audio_impl(text, user, update.message, tts_audio_from_text)
    except BaseException as e:
        logger.error(msg="Exception while gen audio:", exc_info=e)
        await update.message.reply_html("Server Internal Error", reply_to_message_id=reply_id)


async def gen_audio_impl(text: str, user: User, message: Message, syntesize: Callable) -> None:
    filename_result = os.path.abspath(os.path.join(RESULTS_PATH, '{}_{}.wav'.format(user.id, int(time.time()))))
    try:
        voice = db_handle.get_user_voice_setting(user.id)
        emot = get_emotion_name(user.id)
        samples_num = db_handle.get_user_samples_setting(user.id)
        if emot == Emotions.Neutral.name:  # if Neutral then don't prepend emotion string
            emot = None
        syntesize(filename_result, text, voice, get_user_voice_dir(user.id), emot, samples_num)
    except BaseException as e:
        logger.error(f"Audio generation FAILED: called by {user.full_name} with query: {text}", exc_info=e)
        await message.reply_html("Server Internal Error", reply_to_message_id=message.message_id)
    else:
        for sample_ind in range(samples_num):
            sample_file = filename_result.replace(".wav", f"_{sample_ind}.wav")
            voice_file = convert_to_voice(sample_file)
            try:
                with open(voice_file, 'rb') as audio:
                    keyboard = [[InlineKeyboardButton("Regenerate", callback_data=QUERY_PATTERN_RETRY)]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    if len(text) > MAX_CHARS_NUM:  # elide to prevent hitting max caption size
                        text = f"{text[:MAX_CHARS_NUM]}..."
                    await message.reply_voice(voice=audio, caption=text, reply_to_message_id=message.message_id, reply_markup=reply_markup)
            except BaseException as e:
                logger.error(f"Audio generation FAILED SEND FILE: called by {user.full_name}, for sample №{sample_ind} with query: {text}", exc_info=e)
                await message.reply_html("Server Internal Error", reply_to_message_id=message.message_id)
            else:
                logger.info(f"Audio generation DONE: called by {user.full_name}, for sample №{sample_ind}, with query: {text}")
    finally:
        clear_dir(RESULTS_PATH)


@user_restricted
async def retry_button(update: Update, context: CallbackContext) -> None:
    """Parses the CallbackQuery and updates the message text."""
    query = update.callback_query
    user = update.effective_user
    await query.answer()

    logger.info(f"Retry called by {user.full_name}, with id: {user.id}, with query: {query.message.caption}")
    try:
        # TODO get actual message text instead of caption
        await gen_audio_impl(query.message.caption, user, query.message, tts_audio_from_text)
    except BaseException as e:
        logger.error("Retry query FAILED", exc_info=e)


async def help_cmd(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    log_cmd(user, "help_cmd")
    await update.message.reply_text("No help here, yet")  # TODO
